%!TEX root = bertinR.tex
%$HeadURL$
%$Id$
%$Author$

%\VignetteIndexEntry{Bertin Matrices}
%\VignetteIndexEntry{Bertin implementation}
%$HeadURL$

% svn propset svn:keywords "Date Author Id Revision HeadURL" bertinR.Rnw
% setwd("/Users/gs/projects/rforge/bertin/pkg/vignettes")
% enc <- options(width = 56);  Sweave("bertinR.Rnw",output="bertinR.tex", keep.source=TRUE, debug = TRUE, eps = FALSE); options(enc)
%%  #enc <- options(encoding = "MacRoman", width = 56)
% \usepackage{Sweave}
%global flags for conditional builds
%:flags
%\def\private{true}% comment out for public version
\listfiles

\def\solutions{true}% comment out to hide solutions
\def\usehyperref{true}% comment out to skip hyperref

\ifx\pdfoutput\undefined % We're not running pdftex
\documentclass[dvips,12pt,a4paper,twoside]{amsart}
\else
%\documentclass[pdftex,12pt,a4paper,twoside]{amsbook}
\documentclass[pdftex,12pt,a4paper,twoside]{amsart}
\usepackage{thumbpdf}
\pdfcompresslevel=9
\fi

\SweaveOpts{strip.white=true}
\AtBeginDocument{\setkeys{Gin}{width=0.6\textwidth}}

\def\private{true}% comment out for public version

\usepackage{graphicx}
%\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\usepackage[english]{babel}%hyphenation must be after babel
\usepackage[applemac]{inputenc}

%%for debugging:
%\usepackage{showidx}%show index entries per page
%\usepackage{showkeys}%show label, ref and cite keys. Supersedes showlabels

\usepackage{gssda}
\usepackage{bertinR}

\usepackage{amsfonts}
\usepackage[author-year]{amsrefs}
\usepackage{color}


%:layout parameters
\setlength{\parskip}{12pt}
\setlength{\parindent}{0pt}
%! ?? undefined
%\setkeys{Gin}{width=0.9\textwidth}

%\author{G\"unther Sawitzki\\StatLab Heidelberg
%\\\bigskip\bigskip\today
%\bigskip\bigskip \\  \emph{\textcolor{red}{in preparation}}  %?? red undefined ?
%\bigskip\bigskip\bigskip\bigskip\bigskip \\  \emph{http://bertin-forge.r-project.org/}
%}

%:title
\title[Bertin Matrices]{Bertin Matrices\\\bigskip An\  \Rlogo \  Implementation}
%
\author[G\"unther Sawitzki]{G\"unther Sawitzki\\StatLab Heidelberg}
%	\contrib[...]{...} no2 |
\address{Address: StatLab Heidelberg}
%	\curraddr{...} no no
\email{gs@statlab.uni-heidelberg.de}
\urladdr{http://www.statlab.uni-heidelberg.de/projects/r/}
\dedicatory{in preparation}
\date{Aug. 2010.\\
%For quotation, please use the general reference \cite{gs94oned}.\\
Revised: August 2011\\
Typeset, with minor revisions: \today}  
\thanks{\emph{URL:} \url{http://bertin-forge.r-project.org/}}
%	\translator{...} |3 |3
\keywords{statistical computing, S~programming language, R~programming,
data analysis, exploratory statistics, residual diagnostics, R language}
%\date{Aug. 2010, published as technical report \cite{gs92shrth}.\\
%	\subjclass[2000]{...} yes yes
%	\begin{abstract}...\end{abstract} yes4 no

%see: http://theoval.cmp.uea.ac.uk/~nlct/latex/pdfdoc/pdfdoc/pdfdoc.html
\pdfinfo{
   /Author (G. Sawitzki)
   /Title  (Bertin Matrices  - An R Implementation)
   /Subject (Computational Statistics)
   /Keywords (computational statistics, statistical computing, S~programming language, R~programming,
data analysis, exploratory statistics, Bertin, R~language)
}

%%for debugging:
%\usepackage{showidx}%show index entries per page
%\usepackage{showkeys}%show label, ref and cite keys. Supersedes showlabels
%
%%toc upto section level
%\setcounter{tocdepth}{2}
%\setcounter{secnumdepth}{4}
\makeindex

%:\begin{document}
\begin{document}
\setkeys{Gin}{width=1.0\textwidth}
\maketitle

\begingroup
\setlength{\parskip}{0pt}
\tableofcontents
\endgroup

<<echo=FALSE, results=hide>>=
library(xtable)
library(bertin)
data(Hotel)
@
\section{Bertin Plots}
Among the rich material on graphical presentation of information, in \cite{brtn77gtg} (engl. \cite{seriation:Bertin:1999}) J. Bertin discusses the presentation of data matrices, with a particular view to seriation. \cite{seriation:Falguerolles:1997} gives an appraisal of this aspect of Bertin's work. The methods illustrated in \cite{seriation:Falguerolles:1997} have been first implemented in the Voyager system \cite{Sawitzki1996Extensible-Stat}. They have been partially re-implemented in \R{}, and this paper gives an introduction to the R-implementation.

The \R{}-implementation can be downloaded as a package \ircode{bertin} from \url{http://bertin.r-forge.r-project.org/}.  \cite{seriation:Falguerolles:1997} is included in the documentation section of the package.

Bertin uses a small data set on hotel occupancy data to illustrate his ideas.

%:Hotel Data
\begin{table}[htdp]
\begin{center}
%\begin{table}
\tiny{
\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline\\
&Jan&Fev&Mars&Avril&May&Juin&Juil&Aout&Sept&Oct&Nov&Dec\\
\hline
ClienteleFeminine&26&21&26&28&20&20&20&20&20&40&15&40\\
Locale&69&70&77&71&37&36&39&39&55&60&68&72\\
USA&7&6&3&6&23&14&19&14&9&6&8&8\\
AmerSud&0&0&0&0&8&6&6&4&2&12&0&0\\
Europe&20&15&14&15&23&27&22&30&27&19&19&17\\
MOrientAfrique&1&0&0&8&6&4&6&4&2&1&0&1\\
Asie&3&10&6&0&3&13&8&9&5&2&5&2\\
Business&78&80&85&86&85&87&70&76&87&85&87&80\\
Touristes&22&20&15&14&15&13&30&24&13&15&13&20\\
ResDirecte&70&70&78&74&69&68&74&75&68&68&64&75\\
ResAgents&20&18&19&17&27&27&19&19&26&27&21&15\\
EquipageAeriens&10&12&6&9&4&5&7&6&6&5&15&10\\
MoinsDe20&2&2&4&2&2&1&1&2&2&4&2&5\\
De20a55&25&27&37&35&25&25&27&28&24&30&24&30\\
De35a55&48&49&42&48&54&55&53&51&55&46&55&43\\
PlusDe55&25&22&17&15&19&19&19&19&19&20&19&22\\
Prix&163&167&166&174&152&155&145&170&157&174&165&156\\
Duree&1.65&1.71&1.65&1.91&1.9&2&1.54&1.6&1.73&1.82&1.66&1.44\\
Occupation&67&82&70&83&74&77&56&62&90&92&78&55\\
Foires&0&0&0&1&1&1&0&0&1&1&1&1\\
\hline
\end{tabular}
}
%\caption{Bertin's Hotel data}
%\end{table}
\end{center}
\caption{Bertin's hotel data}
\label{tab:hotel}
\end{table}%

\section{Bertin Matrices}

To repeat from  \cite{seriation:Falguerolles:1997}: In abstract terms, a Bertin matrix is a matrix of displays. Bertin matrices allow rearrangements to
transform an initial matrix to a more homogeneous structure. The rearrangements are row or column
permutations, and groupings of rows or columns. To fix ideas, think of a data matrix, variable by
case, with real valued variables. For each variable, draw a bar chart of variable value by case. Highlight
all bars representing a value above some sample threshold for that variable. See Figure \ref{fig:hotel19}.

<<fig=TRUE, include = FALSE, echo=FALSE, results=hide, label=hotel19, width=8, height=2, >>=
# bertinrect(Hotel[19,])
#dev.new(width=8, height=1.5)
#oldpar <- par(no.readonly=TRUE)
col=ifelse(Hotel[19,]>mean(as.matrix(Hotel[19,])),"black","white")
1
 bertinrect(Hotel[19,], main="", col=col,mar=c(0.5,0.3,2,8))
# par(oldpar)
 #bertinrect Hotel[19,], done
 2
@

%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.9\linewidth]{"bertinR-hotel19"}
\caption{Display of one variable. Observations above average are highlighted.}
\label{fig:hotel19}
\end{center}
\end{figure}

Variables are collected in a matrix to display the complete data set.  Figure \ref{fig:hotelorig}. By convention, Bertin shows variables in rows and cases in columns. To make periodic structures more visible, Bertin repeats the data cyclically.

<<fig=TRUE, include = FALSE, echo=FALSE, label=hotelorig,width=8, height=5>>=
#bertinrect Hotel2 start

Hotel2 <- cbind(Hotel,Hotel)
rowmeans <- apply(Hotel2,1,mean)
col=ifelse(Hotel2[,]>rowmeans, "black","white")
bertinrect(Hotel2, main="", col=col,mar=c(0.2,0.2,2,8))
@

%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=1.0\linewidth]{"bertinR-hotelorig"}
\caption{Display of a data matrix. Variables are shown as rows. Time axis is duplicated.}
\label{fig:hotelorig}
\end{center}
\end{figure}

As Bertin points out, the indexing used is arbitrary. You can rearrange rows and/or columns to reveal the information of interest. If you run a hotel, of course the percentage of hotel occupation and the duration of the visits are most interesting for you. Move these variables to the top of the display, and rearrange the other variables by similarity or dissimilarity to these target variables.

<<fig=TRUE, include = FALSE, echo=FALSE, label=hotelperm>>=
colmeans <- apply(Hotel2,1,mean)
rowperm <- c(19,18,20, 8, 11, 4, 12, 13,16,14,1,2, 7, 9, 10, 17, 6, 3, 5,15)
col=ifelse(Hotel2[,]>colmeans, "black","white")
bertinrect(Hotel2[rowperm,], main="", col=col[rowperm,],mar=c(0.5,0.5,2,8))
@

%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.9\linewidth]{"bertinR-hotelperm"}
\caption{Display of a data matrix. Variables rearranged by similarity to occupation and duration.}
\label{fig:hotelperm}
\end{center}
\end{figure}

As a second example, we use the  the \ircode{USJudgeRatings} data set.

<<fig=TRUE, include = FALSE, echo=FALSE, label=judgeorig,width=8, height=5>>=
colmeans <- apply(USJudgeRatings,2,mean)
col=ifelse(USJudgeRatings[,]>colmeans, "black","white")

bertinrect(t(USJudgeRatings),col=t(col), sepwd=0.1, mar=c(0.2,0.2,7,6),main="USJudgeRatings")
@
%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=01.0\linewidth]{"bertinR-judgeorig"}
\caption{Display of a data matrix. Lawyers' ratings of state judges in the US Superior Court.}
\label{fig:hotelperm}
\end{center}
\end{figure}


At this early point, let us put Bertin's work in place. Visualizing information is but one aspect. In statistics, as we see it today, visualization may be one part of an analysis. The outcome will be a decision leading to an action, and then there is a loss (or gain) depending on the action taken on the one hand, and the ``true'' state of the world on the other. Statistics has formulated a few standard problems, and given a suggestion to handle these. In our example, the problem can be seen as a prediction problem: find a prediction model to predict occupation and duration, based on the other variables. This is a control problem, and the statistical contribution is to find a regression model for occupation and duration, based on the other variables. The visualization can be seen as one way to hint at a regression model. There are few classical problems. Regression is one of them, and prediction is closely related. Classification and clustering is another, closely related pair of problems, and their relation to Bertin matrices should be obvious.

\section{Work flow}

We prefer to see Bertin matrices as a part of a work flow.

In a first step, we transfer the input data to allow for  common, or comparable scales. In the Hotel example, Bertin rescales by the maximum value of each variable. The dichotomous variable Faires is recoded as 0/1. Our  implementation default is to rescale for  \ircode{(0, max)} for positive variables,  \ircode{(min, 0)} for negative variables,  \ircode{(min, max)} for general variables. Out preferred, or recommended rescaling however is to use ranks. We use the term \ircode{score} for the rescaled variables. Orientation of the data set is critical  in this step. Usually, rescaling should be by variable, not by case. Depending on the orientation, this can lead for example to ranks by row or by column. We allow global scaling as an additional option for those situations where all data are already on a common scale. Following Bertin, our  implementation default is to expect variables in rows.

In a second step, the scores are translated to visualization attributes.  Colour is handled in two steps. The scores are translated to  a colour index, which is used together with a colour palette to determine the display colour for a data element. This allows rapid experiments with various colour palettes, as long as the length of the palette is compatible. We strongly recommend to always look at the inverted table together with a chosen one  to mitigate the effects of colour  perception. Simple image displays limit the  visualization attributes to colour. \ircode{rect} for example allows rectangle geometry, colour, and border width. Shading and shading should be considered as an alternative for print media. 

Visualization attributes may reflect different aspect. So for example in the classical Bertin display, height of a rectangle is used to reflect the value of a data element, colour is used to show an indicator whether the value is above or below variable mean.

A third step controls the actual placement of the graphical elements. With a matrix layout, it is specified by possible permutations of rows and of columns. This may be related to information used in the first two steps, but should be considered an independent step. A vector or row orders and of column orders is the critical information from this step. Various seriation methods apply. The typical situation is to select scores and display attributes, and then search for optimal or good seriations. The arrangement often leads to hard optimization problems. Placing this step later allows to use information from score transformation and attributes, which may allow more efficient algorithms.

The final step is to merge these informations and render a display. 

%:cart and patches
%We will discuss an implementation of Bertin's ideas. Implementing his examples as is, is trivial. To catch his ideas demands some thoughts, and has immediate consequences for an \R{} environment.
%
\section{Permutation, Seriation, Arrangement}
As Bertin has pointed out,
\begin{quotation}
\emph{Ce point est fondamental. C’est la mobilité interne de l’image qui charactérise la
graphique moderne.} [Bertin 1977, p. 5]
\end{quotation}
Once we have solved the problem, the way can often be formulated as an optimization problem. But while we are searching for a solution, experimenting is necessary. In our implementation, we separate to lines of experiment. Finding an adequate display is one branch. This amounts to building up a collection of proven models, and a certain data set can contribute by hinting at specific needs. This is  repeated not so often. Stability of implementation has priority over speed. We will provide a small number of basic model implementations.

The classic Bertin display shown above is one of the examples. Following the ideas, but deviating in the details, is to use a simple gray scale image for representation. This may be the most economic variant. But it is most economic in the use of display space.
See figure \ref{fig:hotelpermimage}. We will follow the classic Bertin display  and an image display as main examples.
<<fig=TRUE, include = FALSE, echo=FALSE, width=11, height=9, label=hotelpermimage>>=
Hotel2 <-as.matrix(Hotel2)
rowmeans <- apply(Hotel2,1,mean)
rowsd<- apply(Hotel2,1,sd)
zscores <-as.matrix( (Hotel2-rowmeans)/rowsd)
rowperm <- c(19,18,20, 8, 11, 4, 12, 13,16,14,1,2, 7, 9, 10, 17, 6, 3, 5,15)
#col=gray((0:256)/[zscores]
image.bertin(zscores[rowperm,], main="", col=gray((0:256)/256), useRaster=TRUE)
@

%
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=1.0\linewidth]{"bertinR-hotelpermimage"}
\caption{Display of a data matrix as gray scale image. Variables rearranged by similarity to occupation and duration.}
\label{fig:hotelpermimage}
\end{center}
\end{figure}


For a chosen display, we have to compare different arrangements (seriations, for example, If we allow for interactive work, speed of display has priority. We try to cache the information that is invariant of the permutation.

As a final aspect, display space is limited. The number of variables and cases that can be displayed simultaneously is limited by the pixel size of the display. We can increase it by one or two magnitudes by using e series of detail displays. Any display calibration however should be constant for this series We try to allow for this global calibration.

%:strategy
%In very short terms, Bertin's matrix strategies starts with a data matrix, conventionally seen as variables by cases. Is uses three steps.
%\begin{description}
%\item[derive scores ] {This brings the variables to a comparable scale.}
%\item[seriate ] {This brings the seriable to an informative order.}
%\item[visualize ] {This allows to perceive and interpret the data.}
%\end{description}


The restriction to a matrix structure is arbitrary and can be omitted. Bertin has been working as a cartographer, and his main work applies to geographical data. What we call the Bertin matrices has been introduced in the very beginning of his book and are but a starting point. 

\section{Colour, perception and pitfalls}

still to fix

Perception is an active process, and any visual presentation may be swayed by the intricacies of perception. Colour perception is particularly complex. When working with colour (and this includes black and white), we strongly suggest to have a look at the image with inverted colours as well.

Here is a sample implementation. On the \R{} level, provide a plotting function 

%		#imagem(z, xlab=xlab, ylab=ylab, main=main, col=col, mar=c(0.1,,0.1,0.1,0.1))

<<print=FALSE, echo=TRUE >>=
sampleimagem <- function(z, 
	col = grey((1:256)/256), xlab, ylab, main, 
	colinvert=FALSE){
	if (colinvert) col <- col[length(col):1]
	# x1, x2. y1, y2
	oldpar <- par(fig=c(0, 1, 0.2, 1), 
		mar=c(2.5,1.5,0.5,0.5), new=FALSE)
	imagem(z, col=col)
	
	par(yaxt="n", fig=c(0, 1, 0, 0.2), 
		mar=c(3.5,12.0,0.5,12.0), new=TRUE)
#	colramp(col=col, horizontal=TRUE)
	zrange <- range(z, finite=TRUE)
	image(z=t(matrix(seq(zrange[1],zrange[2],length.out=length(col)), 
		1, length(col))), 
		zlim=zrange,main="", ylab="", xlab="", col=col)
	par(oldpar)
}
@
and run it with \ircode{colinvert=FALSE} and  \ircode{colinvert=TRUE} .
If your are using \ircode{Sweave}, use two separate chunks, and place the figure output side by side in \TeX.
%	@
%	%
%	%
%	% By registration
%	\section{By registration}
%	Technical preparation: extract tension by sequential recording number.
%	<<echo=TRUE>>=
%	du_lfd_nr  <-  matrix(nrow=max(d$seqVPNR), ncol=max(d$LFD_NR))
%	for (k in (1:length(d$SPANNUNG))) {
%		du_lfd_nr[d$seqVPNR[k], d$LFD_NR[k]]  <-  d$SPANNUNG[k]}
%	@
%	<<print=FALSE, echo=FALSE>>=
%	graphics.off();quartz(width=8, height=10)
%	@
%	\clearpage
%	% sequence heat
<<fig=TRUE, eps= FALSE, echo=TRUE, height=12, width=10, include=FALSE, label=sampleimagem>>=
hotelrk <- bertinrank(Hotel)
sampleimagem(hotelrk)
@
See Figure \ref{sampleimagem} left.

<<fig=TRUE, echo=TRUE, height=12, width=10, include=FALSE, label=sampleimageminv >>=
sampleimagem(hotelrk, colinvert=TRUE)
@
See Figure \ref{sampleimageminv} right.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.48\linewidth]{bertinR-sampleimagem}
\includegraphics[width=0.48\linewidth]{bertinR-sampleimageminv}
\caption{Test matrix: same information, but colour table inverted on the right.}\label{sampleimagem}\label{sampleimageminv}
\end{center}
\end{figure}
%
%\clearpage

\section{Coordinate System and Conventions}

We provide prototypes for the display of Bertin matrices. To simplify the implementation of extensions, we chose a coordinate system that allots unit square to each matrix cell. If we want to add separator lines to structure our data, we have to allocate additional space \ircode{sepwd}, measured in user space. 

\ircode{image} requires increasing scales for both axes. To align with matrix conventions, we have to transform the row numbers.
% So for a matrix \code{x} the data \code{x[i, j]}

The total user space has the size \ircode{(nrrows * (1+2*sepwd),} \ircode{nrcols * (1+2*sepwd)}. The drwing area for cell \ircode{x[i, j]} is a unit square with bottom left coordinates \ircode{ (nrrows-i+1)*}  \ircode{(1+2*sepwd) -} \ircode{sepwd*} \ircode{(1+} \ircode{2*sepwd)} \ircode{- sepwd,} \ircode{j* (1+2*sepwd) - sepwd }.


\section{Test matrices}

To test the implementation, a series of matrices is provided.

\subsection{Random Matrices}

<<>>=
nrow <- 5
ncol <- 3
BMunif <- matrix(runif(nrow*ncol), nrow, ncol)
colnames(BMunif) <- colnames(BMunif, do.NULL=FALSE)
rownames(BMunif) <- rownames(BMunif, do.NULL=FALSE)

BMnorm <- matrix(rnorm(nrow*ncol), nrow, ncol)
colnames(BMnorm) <- colnames(BMnorm, do.NULL=FALSE)
rownames(BMnorm) <- rownames(BMnorm, do.NULL=FALSE)

@
\subsection{Pure Vanilla}
The most simple case: all variables are on a common scale, and the sequence is given (no seriation possible) or irrelevant (no seriation necessary).

If we want to build test matrices, there are two free parameters to be set, for example
<<>>= 
BMExplRows=8
BMExplCols=6
@
Typical cases are :
<<>>=
BMExplUnif  <- matrix( runif(BMExplRows*BMExplCols), 
	nrow= BMExplRows, ncol= BMExplCols)
BMExplNorm  <- matrix( rnorm(BMExplRows*BMExplCols), 
	nrow= BMExplRows, ncol= BMExplCols)
@

<<fig=TRUE,width=10, height=6,label=imageBMExplUnif>>=
oldpar <- par(mfrow=c(1,2))
imagem(BMExplUnif)
image.bertin(BMExplUnif)
par(oldpar)
@

<<fig=TRUE,width=12, height=6,label=plotBMExplUnif>>=
oldpar <- par(mfrow=c(1,2))
bertinrect(BMExplUnif)
plot.bertin(BMExplUnif)
par(oldpar)
@

<<fig=TRUE,width=12, height=6,label=imageBMExplNorm>>=
oldpar <- par(mfrow=c(1,2))
imagem(BMExplNorm)
image.bertin(BMExplNorm)
par(oldpar)
@

<<fig=TRUE,width=12, height=6,label=plotBMExplNorm>>=
oldpar <- par(mfrow=c(1,2))
bertinrect(BMExplNorm)
plot.bertin(BMExplNorm)
par(oldpar)
@

%
%<<fig=TRUE, label=imagedflt, width=18, height=18>>=
%oldpar <- par(mfrow=c(2,1))
%image(BMExplUnif)
%image(BMExplNorm)
%par(oldpar)
%@

%
The deficits are obvious. The colours used by default appear qualitatively different, but they do not convey quantitative information. This can be easily overcome by using better colour scales. The minimum to do is to use gray scales, but  of course better solutions are readily available.
%<<fig=TRUE,label=imagegy>>=
%oldpar <- par(mfrow=c(2,1))
%image(BMExplUnif,col=grey(0:256/256))
%image(BMExplNorm,col=grey(0:256/256))
%par(oldpar)
%@

The other obvious problem is that image does not  reflect the orientation of the matrix (image uses image-conventions with origin at the bottom left, wheres matrix numeration uses an origin at to top left). Moreover, the aspect ratio of the image does not correspond to the aspect ratio of the matrix. The only solution is to rewrite image to a variant that is adapted to matrix conventions.
<<>>=

@

A hidden problem with image representations is that they provide more information than usually can be processed. The colours ore grey tones may reflect to many differences.
The second cheap solution to present a matrix is an array of  histograms:

%
%<<fig=TRUE, width=16, height=16, label=multhist>>=
%olpar <- par(mfcol=c(3, 2))
%for (row in 1:3) hist(BMExplUnif[row,])
%for (row in 1:3) hist(BMExplNorm[row,])
%par(oldpar)
%@

\subsection{Vanilla}

The next round of test cases are numeric, but not on a common scale. We provide some test vectors which we can use to construct various test matrices.

<<>>=
# Test vectors, used to build a matrix
Bzero <- rep(0, BMExplCols)
Bone <- rep(1, BMExplCols)
Bmone <- rep(-1, BMExplCols)
Binc <- (1:BMExplCols)/BMExplCols
Bdec <- (BMExplCols:1)/BMExplCols
Bstep <- c(Bmone[1:floor(BMExplCols/2)], 
	Bone[(1+floor(BMExplCols/2)):BMExplCols])
Bhat <- Bone
Bhat[(floor(BMExplCols/3)+1):(BMExplCols-floor(BMExplCols/3)) ] <- 0.5
Bnazero <- rep(c(NA,0),length.out= BMExplCols)
Bnanzero <- rep(c(NaN,0),length.out= BMExplCols)
Binf <- rep(c(Inf,0,-Inf),length.out= BMExplCols)

@

<<>>=
# Basic test matrices
Brmatrix <- rbind(Bzero, Bone, Bmone, Binc, Bdec, Bstep, Bhat)
colnames(Brmatrix) <- colnames(Brmatrix,FALSE)

@

<<>>=
## R may use internal housekeeping 
## to keep matrix columns homogeneous. 
## Check!
## Use row matrix and column matrix for tests.
Bcmatrix <- cbind(Bzero, Bone, Bmone, Binc, Bdec, Bstep, Bhat)
rownames(Bcmatrix) <- rownames(Bcmatrix,FALSE)

# Basic test matrices with random error
BrRndmatrix <- Brmatrix+rnorm(nrow(Brmatrix)*ncol(Brmatrix))

@
<<>>=
# Test matrices with IEEE specials
Brmatrixx <- rbind(Bzero, Bone, Bmone, Binc, Bdec, Bstep, Bhat, 
	Bnazero, Bnanzero, Binf)
Bcmatrixx <- cbind(Bzero, Bone, Bmone, Binc, Bdec, Bstep, Bhat, 
	Bnazero, Bnanzero,Binf)

BrRndmatrixx <- Brmatrixx+rnorm(nrow(Brmatrixx)*ncol(Brmatrixx))
@
<<results=tex, echo=FALSE>>=
print(xtable(Brmatrixx,label="Brmatrixx", caption="Brmatrixx: matrix with special values, by row"), floating=TRUE)
@

%

\pagebreak
\bibliographystyle{amsxport}
%\bibstyle{alpha}
\bibliographystyle{amsxport}

\bibliography{./bertin.bib}
\printindex


\ifx\private\undefined%
\else
\vspace{\stretch{1}}
\noindent
{\tiny%
\verb#$Id$#\\
\verb#$Revision$#\\
\verb#$Date$#\\
\verb#$Author$#
}
\fi


\end{document}  